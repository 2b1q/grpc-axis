import { Model } from 'mongoose';
import { Injectable, Logger, HttpException, HttpStatus } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { RedisService } from 'nestjs-redis';

import * as uuid from 'uuid/v4';

import {
  Vehicle,
  OperationResult,
  Snapshot,
  UUID,
} from './interfaces/vehicle.xploitation.interface';

@Injectable()
export class VehicleExploitationService {
  // inject the Snapshot and Vehicle mongoose models/schemas
  // to the VehicleExploitationService using the @InjectModel() decorator
  constructor(
    @InjectModel('Snapshot') private readonly snapshotModel: Model<Snapshot>,
    @InjectModel('Vehicle') private readonly vehicleModel: Model<Vehicle>,
    private readonly redisService: RedisService,
  ) {}

  private logger = new Logger('VehicleExploitationService');
  private logData(method, data) {
    this.logger.warn(
      `call method: ${method} with data  ${JSON.stringify(data)}`,
    );
  }

  private async getClientUuidByToken(token: string): Promise<string> {
    let clientUuid: string | undefined;
    // get client UUID from Redis using auth token
    try {
      const client = await this.redisService.getClient();
      clientUuid = await client.get(`wj:auth:token:${token}`);
    } catch (error) {
      this.logger.error(error);
    }
    // check if client already authorized in Redis
    if (!clientUuid) {
      throw new HttpException('UNAUTHORIZED', HttpStatus.UNAUTHORIZED);
    }
    return clientUuid;
  }

  async addVehicle(vehicle: Vehicle, token: string): Promise<UUID> {
    this.logData('AddVehicle by token', token);
    // check if token exist in gRPC metadata
    if (!token) {
      throw new HttpException('Bad payload', HttpStatus.BAD_REQUEST);
    }
    vehicle.id = uuid(); // generate vehicle UUID (for storing in MongoDB)

    // get client UUID from Redis using auth token
    const cid = await this.getClientUuidByToken(token);
    // check if client already authorized in Redis
    if (!cid) {
      throw new HttpException('UNAUTHORIZED', HttpStatus.UNAUTHORIZED);
    }
    this.logger.log(`Got UUID: "${cid}" by token: "${token}"`, 'addVehicle');
    // set client UUID
    vehicle.driver.clientUuid = cid;
    const newVehicle = new this.vehicleModel(vehicle);
    try {
      newVehicle.save();
      this.logger.log('vehicle saved successfully in mongoDB');
    } catch (error) {
      this.logger.error(error);
      throw new HttpException('Bad payload', HttpStatus.BAD_REQUEST);
    }
    return {
      id: uuid(),
    };
  }

  async addSnapshot(
    snapshot: Snapshot,
    token: string,
  ): Promise<OperationResult> {
    this.logData('AddSnapshot by token', token);
    // check if token exist in gRPC metadata
    if (!token) {
      throw new HttpException('Bad payload', HttpStatus.BAD_REQUEST);
    }

    // get client UUID from Redis using auth token
    const cid = await this.getClientUuidByToken(token);
    // check if client already authorized in Redis
    if (!cid) {
      throw new HttpException('UNAUTHORIZED', HttpStatus.UNAUTHORIZED);
    }
    this.logger.log(`Got UUID: "${cid}" by token: "${token}"`, 'addSnapshot');
    // set client UUID
    snapshot.clientUuid = cid;

    const newSnapshot = new this.snapshotModel(snapshot);
    try {
      await newSnapshot.save();
      this.logger.log('snapshot saved successfully in mongoDB');
    } catch (error) {
      this.logger.error(error);
      throw new HttpException('Bad payload', HttpStatus.BAD_REQUEST);
    }
    return { status: true };
  }

  // get all records
  async getSnaphots(): Promise<any[]> {
    return this.snapshotModel
      .find({})
      .select({ _id: 1, id: 1, vehicleId: 1, clientUuid: 1, updated: 1 })
      .sort({ updated: -1 })
      .exec();
  }

  // getOne snaphot by _id
  async getSnaphot(id: string): Promise<any> {
    try {
      return await this.snapshotModel.findOne({ _id: id }).exec();
    } catch (error) {
      this.logger.error('getSnaphot ERROR', JSON.stringify(error));
      throw new HttpException(`Record "${id}" not exist`, HttpStatus.NOT_FOUND);
    }
  }
}
